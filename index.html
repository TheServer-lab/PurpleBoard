<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Purple Board — Shared (Worker reader) — Accounts</title>
<link rel="icon" href="data:,">
<style>
:root{
  --bg-1: #0f0710;
  --panel: rgba(255,255,255,0.03);
  --accent: #b781ff;
  --accent-2: #6f3df1;
  --muted: #cbbcf2;
  --text: #efe6ff;
  --glass: rgba(255,255,255,0.025);
  --card-border: rgba(255,255,255,0.04);
  --glass-2: rgba(255,255,255,0.015);
  --shadow: 0 8px 24px rgba(0,0,0,0.6);
  --radius: 14px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  background: radial-gradient(1200px 400px at 10% 10%, rgba(167,111,249,0.06), transparent 10%), linear-gradient(180deg,var(--bg-1),#19051a);
  color:var(--text); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
}
header{
  padding:18px 20px; display:flex; align-items:center; justify-content:space-between; gap:16px;
  backdrop-filter: blur(6px);
  background: linear-gradient(90deg, rgba(23,6,31,0.6), rgba(28,7,38,0.45));
  border-bottom: 1px solid var(--card-border);
}
.header-sub{color:var(--muted);font-size:13px}
.container{max-width:1180px;margin:24px auto;padding:18px;display:grid;grid-template-columns:320px 1fr;gap:20px}
.card{
  background: linear-gradient(180deg,var(--glass),var(--glass-2));
  padding:14px;border-radius:var(--radius);border:1px solid var(--card-border);box-shadow:var(--shadow);transition:transform .18s ease,box-shadow .18s ease;
}
.card:hover{transform:translateY(-6px)}
.board-list button{display:block;width:100%;text-align:left;padding:12px;border-radius:10px;border:0;background:transparent;color:var(--muted);margin-bottom:8px;cursor:pointer;font-weight:600}
.board-list button.active{background:linear-gradient(90deg, rgba(183,129,255,0.08), rgba(111,61,241,0.04));color:var(--text);box-shadow:0 8px 20px rgba(111,61,241,0.06)}
input[type="text"],textarea,input[type="file"],select,button{width:100%;padding:10px;border-radius:10px;border:1px solid var(--card-border);background:transparent;color:var(--text);outline:none}
textarea{resize:vertical;min-height:80px}
button.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:0;color:#fff;cursor:pointer;padding:10px 14px;border-radius:10px;font-weight:700;box-shadow:0 8px 22px rgba(111,61,241,0.14);transition:transform .12s ease,opacity .12s}
button.primary:active{transform:translateY(1px)}
.small{font-size:13px;color:var(--muted)}
.thread-list{display:flex;flex-direction:column;gap:12px}
.thread-card{display:flex;gap:14px;padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);align-items:flex-start;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);cursor:pointer;transition:transform .12s,box-shadow .12s}
.thread-card:hover{transform:translateY(-6px);box-shadow:0 18px 40px rgba(0,0,0,0.55)}
.thumb{width:120px;height:auto;border-radius:8px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
.meta{font-size:12px;color:var(--muted)}
.greentext{color:#7cffb2}
.quote{background:rgba(255,255,255,0.02);color:var(--muted);padding:6px;border-radius:6px;display:inline-block;cursor:pointer}
.controls{display:flex;gap:10px;align-items:center}
.thread-view{display:flex;flex-direction:column;gap:12px}
.post{padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.02)}
.reply{margin-left:18px}
.footer-note{font-size:13px;color:var(--muted);margin-top:8px}
.captcha{display:flex;align-items:center;gap:8px;margin-top:6px}
.debug{font-family:monospace;font-size:12px;color:var(--muted);white-space:pre-wrap;margin-top:8px}
.avatar{width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,#6f3df1,#b76cff);display:inline-flex;align-items:center;justify-content:center;font-weight:700;color:#fff;margin-right:10px;font-size:16px}
.post-actions{display:flex;gap:8px;align-items:center;margin-top:10px}
.action-btn{background:transparent;border:1px solid var(--card-border);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;font-weight:600}
.action-btn:hover{color:var(--text);border-color:var(--accent)}
.permalink{font-size:13px;color:var(--muted);margin-left:8px}
.op-badge{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;font-weight:700;padding:4px 8px;border-radius:8px;font-size:12px;margin-left:8px}
.timeago{color:var(--muted);font-size:12px;margin-left:6px}
.empty{color:var(--muted);padding:18px;text-align:center}
.lightbox{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:9999}
.lightbox img{max-width:95%;max-height:95%;border-radius:10px}
.copy-toast{position:fixed;right:18px;bottom:18px;background:#1b0b2a;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:0 8px 24px rgba(0,0,0,0.6)}
.profile-modal{position:fixed;right:28px;top:28px;width:380px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.04);z-index:10000;box-shadow:0 18px 40px rgba(0,0,0,0.6)}
.profile-modal h3{margin:0 0 6px 0}
.profile-meta{display:flex;align-items:center;gap:12px}
.profile-posts{margin-top:10px;max-height:300px;overflow:auto}
.profile-empty{color:var(--muted);padding:10px;border-radius:8px;background:rgba(255,255,255,0.01)}
@media (max-width:980px){ .container{grid-template-columns:1fr} .thumb{display:none} .profile-modal{left:12px;right:12px;width:auto;top:12px} }
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
</style>
</head>
<body>
<header>
  <div style="display:flex;align-items:center;gap:12px"><h1>Purple Board</h1><div class="small header-sub">Shared imageboard — posts → Discord webhooks; reads → Cloudflare Worker</div></div>
  <div id="accountArea" class="small"></div>
</header>

<div class="container">
  <aside class="card">
    <div><strong>Boards</strong></div>
    <div class="board-list" id="boardList" style="margin-top:10px"></div>

    <!-- STATIC ACCOUNT CARD (always visible) -->
    <div class="card" style="margin-top:12px">
      <strong>Account</strong>
      <div style="margin-top:8px">
        <!-- Static fallback login/register UI (always visible) -->
        <div id="authFormsStatic" style="display:block; gap:6px;">
          <div id="registerBlock" style="margin-bottom:8px">
            <div style="font-weight:700;margin-bottom:6px">Register</div>
            <input id="regUser" placeholder="username" style="margin-top:6px">
            <input id="regPass" placeholder="password" type="password" style="margin-top:6px">
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="regBtn" class="small">Register</button>
              <button id="toLoginBtn" class="small">Switch to Login</button>
            </div>
          </div>

          <div id="loginBlock" style="display:none;margin-top:8px">
            <div style="font-weight:700;margin-bottom:6px">Login</div>
            <input id="loginUser" placeholder="username" style="margin-top:6px">
            <input id="loginPass" placeholder="password" type="password" style="margin-top:6px">
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="loginBtn" class="small">Login</button>
              <button id="toRegBtn" class="small">Switch to Register</button>
            </div>
          </div>
        </div>

        <!-- dynamic logged-in box (used when JS sets current user) -->
        <div id="loggedInBox" style="display:none;margin-top:8px">
          <div class="account-row" style="display:flex;align-items:center;">
            <div class="avatar" id="accountAvatar">U</div>
            <div style="margin-left:8px">
              <div id="accountName" style="font-weight:700"></div>
              <div class="small" id="accountEmail"></div>
            </div>
          </div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="logoutBtn" class="small">Logout</button>
            <button id="botLoginBtn" class="small">Login via Bot</button>
          </div>
        </div>
      </div>
      <div class="small" style="margin-top:8px">Register or login to post with a persistent name. Passwords are hashed in your browser before storage. (Demo only — don't use real passwords.)</div>
    </div>

    <div class="card" style="margin-top:12px">
      <strong>Quick help</strong>
      <div class="small" style="margin-top:8px">Pick a board, post text & image. Click posts to open threads. Use the Share button to share via the website (or copy a Discord permalink).</div>
    </div>
  </aside>

  <main>
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>New Post / Thread</strong></div>
        <div class="small" id="selectedBoardName"></div>
      </div>

      <label class="small" style="margin-top:8px">Comment</label>
      <textarea id="comment" rows="4" placeholder="Say something (use >greentext or >>messageId to quote)"></textarea>

      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <input id="file" type="file" accept="image/*" style="flex:1">
        <label style="display:flex;align-items:center;gap:6px;margin-left:6px"><input id="asThread" type="checkbox"> OP (new thread)</label>
      </div>

      <div class="captcha">
        <label style="display:flex;align-items:center;gap:8px"><input id="fakeCaptcha" type="checkbox"> I'm human (demo)</label>
        <div class="small">Client-side captcha — optional</div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
        <button class="primary" id="postBtn">Post (Ctrl+Enter)</button>
        <div id="status" class="small"></div>
      </div>

      <div class="footer-note">Local cooldown & daily limits enforced for convenience.</div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Threads (shared)</strong>
        <div class="controls">
          <button id="refreshBtn" class="small">Refresh</button>
          <button id="healthBtn" class="small">Worker health</button>
          <div id="debugHint" class="small" style="margin-left:8px"></div>
        </div>
      </div>

      <div id="threads" class="thread-list" style="margin-top:10px"></div>
      <div id="debug" class="debug" style="display:none"></div>
    </div>

    <div class="card" id="threadViewCard" style="display:none">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Thread View</strong>
        <div><button id="backBtn" class="small">Back</button></div>
      </div>
      <div id="threadView" class="thread-view"></div>

      <div style="margin-top:8px" class="post">
        <textarea id="replyText" rows="3" placeholder="Reply"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input id="replyFile" type="file" accept="image/*">
          <button class="primary" id="replyBtn">Reply</button>
          <div id="replyStatus" class="small"></div>
        </div>
      </div>
    </div>

  </main>
</div>

<!-- Lightbox -->
<div id="lightbox" class="lightbox" style="display:none" onclick="hideLightbox()"><img id="lightboxImg" src="" alt=""/></div>

<!-- Copy toast -->
<div id="copyToast" class="copy-toast" style="display:none">Link copied to clipboard</div>

<script>
/* =============== CONFIG =============== */
const WORKER_BASE = 'https://pbordworker.dassouraasish.workers.dev';
const BOARDS = {
  "art": { webhook: "https://discord.com/api/webhooks/1456573325148164128/UlQfAb8WE1hWw_uBCs01QPuLjuBg4HAjKAyifGjs0-YDqjIB75Ee1RMvBX0EmoXwE8Xi", channel: "1456573205237203045" },
  "tech": { webhook: "https://discord.com/api/webhooks/1456573404521173041/pxVoHmjnnYTjwEH1EDmf6uMvVbQD3vPogizcyt_5T16AaNUStyw3XyWEniiCvRegprAg", channel: "1456573234009997453" },
  "random": { webhook: "https://discord.com/api/webhooks/1456573475815690395/lb5_p1w6MXf852xPI67v9BPRqSicH_gvpf1C2ki2AmKyb7xL0nUHCrBhsBRrxzSrD26P", channel: "1456573259561701490" }
};
const COOLDOWN_SECONDS = 12;
const DAILY_LIMIT = 200;
const GUILD_ID = '1283171828214534165';
const SHARE_WEBHOOK = 'https://discord.com/api/webhooks/1456575897443238073/Uva4p8ZmCpq4NSn3ayyuqHaFJWA_gH0SQZ83jNXNi3QSy03L2FVFO88YqW8UsH8PBDbO';
const SYNC_USERS_TO_WEBHOOK = false;
/* ===================================== */

const $ = id => document.getElementById(id);
const boardListEl = $('boardList'), selectedBoardNameEl = $('selectedBoardName'), threadsEl = $('threads');
const postBtn = $('postBtn'), refreshBtn = $('refreshBtn'), healthBtn = $('healthBtn'), debugEl = $('debug'), debugHint = $('debugHint');
const copyToast = $('copyToast');
let selectedBoard = null, selectedBoardWebhook = null, viewingThreadId = null;

// helpers
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }
function timeAgo(ts){ const t = Date.parse(ts); if(isNaN(t)) return ''; const s = Math.floor((Date.now()-t)/1000); if(s<60) return `${s}s`; if(s<3600) return `${Math.floor(s/60)}m`; if(s<86400) return `${Math.floor(s/3600)}h`; return `${Math.floor(s/86400)}d`; }
function initials(name){ if(!name) return 'U'; return name.trim().split(/\s+/).map(p=>p[0].toUpperCase()).slice(0,2).join(''); }

/* Accounts */
function randomHex(bytes=8){ const a=new Uint8Array(bytes); crypto.getRandomValues(a); return Array.from(a).map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function hashPassword(salt, password){ const enc = new TextEncoder(); const data = enc.encode(salt + '|' + password); const buf = await crypto.subtle.digest('SHA-256', data); return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join(''); }

function loadUsers(){ return JSON.parse(localStorage.getItem('pb_users')||'[]'); }
function saveUsers(u){ localStorage.setItem('pb_users', JSON.stringify(u)); }
function getToken(){ return localStorage.getItem('pb_token'); }
function setToken(token){ if(token) localStorage.setItem('pb_token', token); else localStorage.removeItem('pb_token'); }
function getCurrentUser(){ return JSON.parse(localStorage.getItem('pb_current')||'null'); }
function setCurrentUser(user, token){
  if(user) localStorage.setItem('pb_current', JSON.stringify(user));
  else localStorage.removeItem('pb_current');
  setToken(token||null);
  updateAccountUI();
}
function logout(){ localStorage.removeItem('pb_current'); setToken(null); updateAccountUI(); }

/* API helpers */
async function apiFetch(path, opts = {}) {
  const url = WORKER_BASE.replace(/\/$/,'') + path;
  const headers = Object.assign({ 'Content-Type': 'application/json' }, opts.headers || {});
  const token = getToken();
  if(token) headers['Authorization'] = 'Bearer ' + token;
  const finalOpts = Object.assign({}, opts, { headers });
  return fetch(url, finalOpts);
}
async function apiPost(path, body){ return apiFetch(path, { method:'POST', body: JSON.stringify(body) }); }
async function apiGet(path){ return apiFetch(path, { method:'GET' }); }

/* Register/Login handlers (client) */
async function onRegister(){
  const u = $('regUser').value.trim(); const p = $('regPass').value;
  if(!u || !p){ alert('Provide username & password'); return; }
  const users = loadUsers();
  const salt = randomHex(12); const h = await hashPassword(salt,p);
  try {
    const res = await apiPost('/register', { username: u, salt, hash: h });
    if(!res.ok){ const txt = await res.text().catch(()=> ''); alert('Register failed: ' + res.status + ' ' + txt); return; }
    users.push({ username: u, salt, hash: h, created: new Date().toISOString() }); saveUsers(users);
    // attempt login to get token
    const loginRes = await apiPost('/login', { username: u, password: p });
    if(loginRes.ok){
      const body = await loginRes.json().catch(()=>null);
      if(body && body.ok && body.token){ setCurrentUser({ username: u }, body.token); alert('Registered and logged in as ' + u); return; }
    }
    setCurrentUser({ username: u }, null);
    alert('Registered (no token). You may need to login to obtain a session token.');
  } catch(e){ console.error(e); alert('Registration failed (console)'); }
}

async function onLogin(){
  const u = $('loginUser').value.trim() || $('regUser').value.trim();
  const p = $('loginPass').value || $('regPass').value;
  if(!u || !p){ alert('Provide username & password'); return; }
  try {
    const res = await apiPost('/login', { username: u, password: p });
    if(!res.ok){ const txt = await res.text().catch(()=> ''); alert('Login failed: ' + res.status + ' ' + txt); return; }
    const body = await res.json().catch(()=>null);
    if(body && body.ok){ const token = body.token || null; setCurrentUser({ username: u }, token); alert('Logged in as ' + u); } else alert('Login failed: ' + (body && body.reason ? body.reason : 'unknown'));
  } catch(e){ console.error(e); alert('Login failed (console)'); }
}

/* Update UI for account area */
function updateAccountUI(){
  const cur = getCurrentUser();
  const regBlock = document.getElementById('registerBlock');
  const loginBlock = document.getElementById('loginBlock');
  if(cur && cur.username){
    $('loggedInBox').style.display='block';
    if(regBlock) regBlock.style.display='none';
    if(loginBlock) loginBlock.style.display='none';
    $('accountName').textContent = cur.username;
    $('accountAvatar').textContent = initials(cur.username);
    $('accountEmail').textContent = (getToken()? 'Session: stored' : '');
  } else {
    $('loggedInBox').style.display='none';
    if(regBlock) regBlock.style.display='';
    if(loginBlock) loginBlock.style.display='none';
  }
}

/* try to call a bot login endpoint on the worker (optional) */
async function botLogin(){
  const cur = getCurrentUser(); if(!cur || !cur.username){ alert('Login first'); return; }
  if(!WORKER_BASE){ alert('No worker base set'); return; }
  try{
    const res = await fetch(WORKER_BASE.replace(/\/$/,'') + '/bot-login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username: cur.username }) });
    const txt = await res.text();
    alert('Bot login response: ' + res.status + '\n' + txt);
  }catch(e){ alert('Bot login failed — worker may not implement /bot-login'); console.error(e); }
}

/* UI init */
function init(){
  boardListEl.innerHTML = '';
  for(const k in BOARDS){
    const b = document.createElement('button'); b.textContent = '/'+k+'/'; b.dataset.board = k; b.onclick = ()=> selectBoard(k,b); boardListEl.appendChild(b);
  }
  const first = Object.keys(BOARDS)[0]; if(first) selectBoard(first, boardListEl.querySelector('button'));
  postBtn.addEventListener('click', onPost);
  refreshBtn.addEventListener('click', ()=> loadThreads(true));
  healthBtn.addEventListener('click', checkHealth);
  $('backBtn').addEventListener('click', ()=> $('threadViewCard').style.display='none');
  $('replyBtn').addEventListener('click', onReply);
  $('logoutBtn').addEventListener('click', ()=>{ logout(); });
  $('botLoginBtn').addEventListener('click', ()=> botLogin());
  debugHint.textContent = 'Worker: ' + (WORKER_BASE?WORKER_BASE.replace(/^https?:\/\//,''):'(not set)');
  document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); if(document.activeElement && (document.activeElement.tagName==='TEXTAREA' || document.activeElement.tagName==='INPUT')) postBtn.click(); }});

  // wire static account buttons
  document.getElementById('regBtn').addEventListener('click', onRegister);
  document.getElementById('loginBtn').addEventListener('click', onLogin);
  document.getElementById('toLoginBtn').addEventListener('click', () => {
    document.getElementById('registerBlock').style.display = 'none';
    document.getElementById('loginBlock').style.display = '';
  });
  document.getElementById('toRegBtn').addEventListener('click', () => {
    document.getElementById('loginBlock').style.display = 'none';
    document.getElementById('registerBlock').style.display = '';
  });

  // profile modal controls
  const closeProfileBtn = document.getElementById('closeProfile');
  if(closeProfileBtn) closeProfileBtn.addEventListener('click', hideProfileModal);
  const fetchRemoteBtn = document.getElementById('fetchRemotePosts');
  if(fetchRemoteBtn) fetchRemoteBtn.addEventListener('click', async () => {
    const name = document.getElementById('profileName').textContent;
    await fetchRemotePosts(name);
  });

  // verify token if present
  verifyTokenOnLoad().then(()=> {
    updateAccountUI();
    loadThreads(false);
  }).catch(()=> {
    updateAccountUI();
    loadThreads(false);
  });
}
init();

/* verify token on load by calling /whoami if available */
async function verifyTokenOnLoad(){
  const token = getToken();
  if(!token) return;
  try {
    const res = await apiGet('/whoami');
    if(!res.ok) { console.warn('/whoami returned', res.status); return; }
    const body = await res.json().catch(()=>null);
    if(body && body.username){ setCurrentUser({ username: body.username }, token); }
  } catch(e){ console.warn('whoami verify failed', e); }
}

/* Posting/Replies (use logged-in username or Anonymous) */
async function onPost(){
  $('status').textContent = '';
  if(!selectedBoard){ $('status').textContent='Select a board'; return; }
  const cur = getCurrentUser();
  const author = cur && cur.username ? cur.username : 'Anonymous';
  const comment = $('comment').value.trim(); const file = $('file').files[0]; const isThread = $('asThread').checked;
  if(!comment && !file){ $('status').textContent='Write something or attach an image'; return; }
  if(!$('fakeCaptcha').checked){ $('status').textContent='Complete captcha (demo)'; return; }

  const lastKey = `last_${selectedBoard}`; const last = Number(localStorage.getItem(lastKey)||0); const nowTs = Date.now();
  if(nowTs - last < COOLDOWN_SECONDS*1000){ $('status').textContent = `Cooldown: wait ${Math.ceil((COOLDOWN_SECONDS*1000 - (nowTs-last))/1000)}s`; return; }
  const dailyKey = `daily_${selectedBoard}`; const daily = JSON.parse(localStorage.getItem(dailyKey)||'[]').filter(t=>nowTs-t<24*3600*1000);
  if(daily.length >= DAILY_LIMIT){ $('status').textContent='Daily limit reached'; return; }

  $('status').textContent = 'Posting...';
  const fd = new FormData(); const content = (author?author+'\n':'') + comment + (isThread? '\n[THREAD]':'');
  fd.append('content', content); if(file) fd.append('file', file);

  try {
    const r = await fetch(webhookWithWait(selectedBoardWebhook), { method: 'POST', body: fd });
    if(!r.ok) throw new Error('post failed: '+r.status);
    const json = await r.json().catch(()=>({ id:String(Date.now()), content })); 
    const localKey = `posts_${selectedBoard}`; const posts = JSON.parse(localStorage.getItem(localKey)||'[]');
    const post = { id: json.id||String(Date.now()), content: json.content||content, ts: json.timestamp||new Date().toISOString(), attachments: json.attachments||[], parent: null, isOP: isThread, name: author };
    posts.unshift(post); localStorage.setItem(localKey, JSON.stringify(posts));
    localStorage.setItem(lastKey, String(nowTs)); daily.unshift(nowTs); localStorage.setItem(dailyKey, JSON.stringify(daily));
    $('status').textContent='Posted ✓'; $('comment').value=''; $('file').value=''; $('asThread').checked=false;
    setTimeout(()=> loadThreads(true), 1200);
  } catch(e){ console.error(e); $('status').textContent='Post failed (console)'; }
}

async function onReply(){
  const threadId = viewingThreadId; if(!threadId){ $('replyStatus').textContent='No thread selected'; return; }
  const cur = getCurrentUser();
  const author = cur && cur.username ? cur.username : 'Anonymous';
  const text = $('replyText').value.trim(); const file = $('replyFile').files[0];
  if(!text && !file){ $('replyStatus').textContent='Write something or attach image'; return; }
  const content = (author?author+'\n':'') + `>>${threadId}\n` + text;
  const fd = new FormData(); fd.append('content', content); if(file) fd.append('file', file);
  $('replyStatus').textContent = 'Posting reply...';
  try{
    const r = await fetch(webhookWithWait(selectedBoardWebhook), { method:'POST', body: fd });
    if(!r.ok) throw new Error('reply failed: '+r.status);
    const json = await r.json().catch(()=>({ id:String(Date.now()), content }));
    const localKey = `posts_${selectedBoard}`; const posts = JSON.parse(localStorage.getItem(localKey)||'[]');
    const post = { id: json.id||String(Date.now()), content: json.content||content, ts: json.timestamp||new Date().toISOString(), attachments: json.attachments||[], parent: threadId, isOP:false, name:author };
    posts.unshift(post); localStorage.setItem(localKey, JSON.stringify(posts));
    $('replyStatus').textContent='Replied ✓'; $('replyText').value=''; $('replyFile').value='';
    renderThreadView(threadId); setTimeout(()=> loadThreads(true),1200);
  }catch(e){ console.error(e); $('replyStatus').textContent='Error posting reply'; }
}

/* Threads loading/rendering (unchanged) */
async function loadThreads(force=false){
  threadsEl.innerHTML = 'Loading…'; debugEl.style.display='none'; debugEl.textContent='';
  if(!WORKER_BASE || WORKER_BASE.includes('PASTE')) { threadsEl.innerHTML='Set WORKER_BASE in HTML'; return; }
  if(!selectedBoard){ threadsEl.innerHTML='Select a board'; return; }
  const channel = BOARDS[selectedBoard] && BOARDS[selectedBoard].channel; if(!channel){ threadsEl.innerHTML='Board missing channel id'; return; }

  try{
    const url = `${WORKER_BASE.replace(/\/$/,'')}/messages?channel_id=${channel}&limit=80`;
    const res = await fetch(url);
    if(!res.ok){
      const txt = await res.text().catch(()=>'');
      let friendly = `Server returned ${res.status}`;
      try{
        const parsed = JSON.parse(txt);
        if(parsed && parsed.error === 'discord_error' && parsed.text){
          try{
            const inner = JSON.parse(parsed.text);
            if(inner && inner.message && inner.code){
              friendly = `Discord API: ${inner.message} (code ${inner.code})`;
              if(inner.code===10003 || /Unknown Channel/i.test(inner.message)) friendly += ' — Unknown Channel. Check channel ID & bot permissions.';
            } else friendly = `Discord API error: ${JSON.stringify(inner)}`;
          }catch(e){ friendly = `Discord error: ${parsed.text}`; }
        } else if(parsed && parsed.message) friendly = `Discord: ${parsed.message}`;
        else friendly = `Server: ${txt}`;
      }catch(e){ friendly = `Server returned ${res.status} — response: ${txt}`; }
      threadsEl.innerHTML = `Failed to load messages (server returned ${res.status})`;
      debugEl.style.display='block'; debugEl.textContent = `URL: ${url}\nStatus: ${res.status}\nFriendly: ${friendly}\nRaw:\n${txt}`;
      return;
    }
    const data = await res.json();
    const localKey = `posts_${selectedBoard}`; const localPosts = JSON.parse(localStorage.getItem(localKey)||'[]');
    const byId = new Map(); data.forEach(m=>byId.set(m.id,m));
    localPosts.forEach(lp=>{ if(!byId.has(lp.id)) byId.set(lp.id,{ id:lp.id, content:lp.content, timestamp:lp.ts||lp.timestamp, author_name:lp.name||'You', attachments:lp.attachments||[], parent:lp.parent||null, isOP:lp.isOP||false }); });
    const merged = Array.from(byId.values()).sort((a,b)=> new Date(b.timestamp) - new Date(a.timestamp));
    const threads = groupToThreads(merged);
    renderThreads(threads);
  }catch(e){ console.error(e); threadsEl.innerHTML='Failed to load messages (console)'; debugEl.style.display='block'; debugEl.textContent=String(e); }
}

function groupToThreads(msgs){
  const map = new Map(); msgs.forEach(m=>map.set(m.id,m));
  const threads = new Map(); msgs.forEach(m=>threads.set(m.id,{ op:m, replies:[] }));
  msgs.forEach(m=>{
    if(!m.content) return;
    const match = m.content.match(/>>(\d{1,20})/);
    if(match){
      const ref = match[1];
      if(map.has(ref)){
        const t = threads.get(ref) || { op: map.get(ref), replies:[] };
        t.replies.push(m); threads.set(ref,t);
        if(threads.has(m.id)) threads.delete(m.id);
      }
    }
  });
  return Array.from(threads.values()).sort((a,b)=> new Date(b.op.timestamp) - new Date(a.op.timestamp));
}

function renderThreads(threads){
  threadsEl.innerHTML = '';
  if(!threads.length){ threadsEl.innerHTML = '<div class="empty">No threads found.</div>'; return; }
  threads.forEach(t=>{
    const op = t.op;
    const card = document.createElement('div'); card.className='thread-card';
    card.addEventListener('click', (e)=>{ if(e.target.closest('.action-btn')) return; openThread(op.id); });

    const left = document.createElement('div'); left.style.width='120px';
    if(op.attachments && op.attachments[0] && op.attachments[0].url){
      const img=document.createElement('img'); img.src=op.attachments[0].url; img.className='thumb'; img.loading='lazy';
      img.onclick=(ev)=>{ ev.stopPropagation(); showLightbox(op.attachments[0].url); };
      left.appendChild(img);
    }
    const right = document.createElement('div'); right.style.flex='1';
    const header = document.createElement('div');
    const avatar = document.createElement('span'); avatar.className='avatar'; avatar.textContent = initials(op.author_name || (op.name||'U'));
    header.appendChild(avatar);
    const title = document.createElement('div'); title.innerHTML = `<strong>${escapeHtml(op.author_name||op.name||'unknown')}</strong> <span class="timeago">${timeAgo(op.timestamp)}</span>`;
    if(op.isOP || (op.content && /\[THREAD\]/i.test(op.content))) { const b = document.createElement('span'); b.className='op-badge'; b.textContent='OP'; title.appendChild(b); }
    header.appendChild(title);
    const body = document.createElement('div'); body.style.marginTop='8px'; body.innerHTML = formatText(op.content||'');
    const actions = document.createElement('div'); actions.className='post-actions';
    const shareBtn = document.createElement('button'); shareBtn.className='action-btn'; shareBtn.textContent='Share'; shareBtn.onclick = (e)=>{ e.stopPropagation(); sharePost(op.id); };
    const shareSiteBtn = document.createElement('button'); shareSiteBtn.className='action-btn'; shareSiteBtn.textContent='Share (site)'; shareSiteBtn.onclick = (e)=>{ e.stopPropagation(); shareViaSite(op.id, op); };
    const quoteBtn = document.createElement('button'); quoteBtn.className='action-btn'; quoteBtn.textContent='Quote'; quoteBtn.onclick = (e)=>{ e.stopPropagation(); insertQuote(op.id); };
    const repliesCount = document.createElement('span'); repliesCount.className='permalink'; repliesCount.textContent = `${t.replies.length} replies`;
    actions.appendChild(shareBtn); actions.appendChild(shareSiteBtn); actions.appendChild(quoteBtn); actions.appendChild(repliesCount);

    right.appendChild(header); right.appendChild(body); right.appendChild(actions);
    card.appendChild(left); card.appendChild(right);
    threadsEl.appendChild(card);

    body.querySelectorAll('.quote').forEach(q=>{
      q.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        const id = q.dataset.id;
        if(findThreadById(id)) openThread(id);
        else { insertQuote(id); flash(`Quoted >>${id} into compose box`); }
      });
    });
  });
}

function openThread(opId){ viewingThreadId = opId; $('threadViewCard').style.display='block'; renderThreadView(opId); window.scrollTo({top:0,behavior:'smooth'}); }
function renderThreadView(opId){
  const wrap = $('threadView'); wrap.innerHTML='Loading…';
  const channel = BOARDS[selectedBoard].channel;
  fetch(`${WORKER_BASE.replace(/\/$/,'')}/messages?channel_id=${channel}&limit=200`).then(r=>r.json()).then(data=>{
    const byId = new Map(); data.forEach(m=>byId.set(m.id,m));
    const local = JSON.parse(localStorage.getItem(`posts_${selectedBoard}`) || '[]');
    local.forEach(p=>{ if(!byId.has(p.id)) byId.set(p.id,{ id:p.id, content:p.content, timestamp:p.ts, author_name:p.name||'You', attachments:p.attachments||[], parent:p.parent||null }); });
    const op = byId.get(opId);
    if(!op){ wrap.innerHTML = '<div class="small">Thread not found — try Refresh or open in Discord</div>'; return; }
    wrap.innerHTML = '';
    const opDiv = document.createElement('div'); opDiv.className='post';
    opDiv.innerHTML = `<div style="font-weight:700">${escapeHtml(op.author_name||op.name||'unknown')}</div><div class="meta">${new Date(op.timestamp).toLocaleString()} <span class="timeago">(${timeAgo(op.timestamp)})</span></div><div style="margin-top:8px">${formatText(op.content)}</div>`;
    if(op.attachments && op.attachments[0] && op.attachments[0].url){ const im=document.createElement('img'); im.src=op.attachments[0].url; im.style.maxWidth='640px'; im.style.marginTop='8px'; im.onclick=()=>showLightbox(im.src); opDiv.appendChild(im); }
    wrap.appendChild(opDiv);
    const replies = [];
    byId.forEach(m=>{ if(m.content && m.content.includes('>>'+opId)) replies.push(m); });
    local.filter(p=>p.parent===opId).forEach(lp=>replies.push(lp));
    replies.sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));
    replies.forEach(r=>{ const d = document.createElement('div'); d.className='post reply'; d.innerHTML = `<div class="meta">${escapeHtml(r.author_name||r.name||'unknown')} • ${new Date(r.timestamp).toLocaleString()} <span class="timeago">(${timeAgo(r.timestamp)})</span></div><div style="margin-top:6px">${formatText(r.content)}</div>`; if(r.attachments && r.attachments[0] && r.attachments[0].url){ const im=document.createElement('img'); im.src=r.attachments[0].url; im.style.maxWidth='420px'; im.style.marginTop='8px'; im.onclick=()=>showLightbox(im.src); d.appendChild(im); } wrap.appendChild(d); });
  }).catch(e=>{ console.error(e); wrap.innerHTML='<div class="small">Failed to load thread</div>'; });
}

function formatText(text){
  if(!text) return '';
  let t = escapeHtml(text);
  t = t.replace(/^&gt;(.+)$/gm, (m,p1) => `<div class="greentext">&gt;${escapeHtml(p1)}</div>`);
  t = t.replace(/&gt;&gt;(\d{1,20})/g, (m,id) => `<span class="quote" data-id="${id}">&gt;&gt;${id}</span>`);
  t = t.replace(/(https?:\/\/[^\s]+)/g, m => `<a href="${m}" target="_blank">${m}</a>`);
  return t.replace(/\n/g,'<br>');
}
function findThreadById(id){ return threadsEl.querySelector(`.quote[data-id="${id}"]`); }
function discordPermalink(messageId){ const channel = BOARDS[selectedBoard].channel; return `https://discord.com/channels/${GUILD_ID}/${channel}/${messageId}`; }

async function sharePost(messageId){
  const url = discordPermalink(messageId);
  try{ await navigator.clipboard.writeText(url); showCopyToast('Link copied'); if(navigator.share){ try{ await navigator.share({ title: 'Purple Board post', url }); }catch(e){} } }catch(e){ console.error('share failed', e); showCopyToast('Copy failed'); }
}

async function shareViaSite(messageId, post){
  const siteUrl = window.location.origin + window.location.pathname + `#post-${selectedBoard}-${messageId}`;
  try{ await navigator.clipboard.writeText(siteUrl); showCopyToast('Site link copied'); }catch(e){ console.warn('copy failed', e); }
  if(SHARE_WEBHOOK){
    try{
      const author = (post && (post.author_name||post.name)) || 'unknown';
      const fd = new FormData(); fd.append('content', `${author} shared ${siteUrl}`);
      await fetch(webhookWithWait(SHARE_WEBHOOK), { method:'POST', body: fd });
    }catch(e){ console.warn('share webhook failed',e); }
  }
  if(navigator.share){ try{ await navigator.share({ title: 'Purple Board — post', url: siteUrl }); }catch(e){} }
}

function insertQuote(id){ const ta = $('comment'); ta.focus(); const v = ta.value; const toIns = (v && !v.endsWith('\n')? '\n':'') + `>>${id}\n`; ta.value = v + toIns; flash(`Inserted >>${id}`); }
function flash(msg){ const s = $('status'); s.textContent = msg; setTimeout(()=>{ if(s.textContent===msg) s.textContent = ''; }, 2200); }
function showLightbox(src){ $('lightboxImg').src = src; $('lightbox').style.display = 'flex'; }
function hideLightbox(){ $('lightbox').style.display = 'none'; $('lightboxImg').src = ''; }
let toastTimer = null;
function showCopyToast(text){ copyToast.textContent = text || 'Copied'; copyToast.style.display = 'block'; clearTimeout(toastTimer); toastTimer = setTimeout(()=> copyToast.style.display = 'none', 2200); }
function checkHealth(){ if(!WORKER_BASE){ alert('Set WORKER_BASE'); return; } fetch(WORKER_BASE.replace(/\/$/,'') + '/health').then(async r=>{ const txt = await r.text(); alert('Health: '+r.status + '\n' + txt); }).catch(e=>{ alert('Health check failed — see console'); console.error(e); }); }

setInterval(()=> loadThreads(true), 20000);
window.loadThreads = loadThreads;
window.openThread = openThread;

// profile modal
function openProfile(username){ location.hash = '#profile-' + encodeURIComponent(username); }
window.addEventListener('hashchange', renderProfileFromHash);
function renderProfileFromHash(){ const h = location.hash || ''; if(!h.startsWith('#profile-')){ hideProfileModal(); return; } const username = decodeURIComponent(h.slice(9)); showProfileModal(username); }
function showProfileModal(username){ const modal = document.getElementById('profileModal'); if(!modal) return; modal.style.display = 'block'; modal.setAttribute('aria-hidden','false'); document.getElementById('profileName').textContent = username; document.getElementById('profileAvatar').textContent = initials(username); const users = loadUsers(); const found = users.find(u=>u.username===username); document.getElementById('profileCreated').textContent = found ? 'Joined: ' + new Date(found.created).toLocaleString() : 'Local profile: not registered'; const postsEl = document.getElementById('profilePosts'); postsEl.innerHTML = '<div class="small">Loading local posts…</div>'; const localMatches = []; Object.keys(localStorage).forEach(k => { if(!k.startsWith('posts_')) return; const arr = JSON.parse(localStorage.getItem(k) || '[]'); arr.forEach(p => { try { const author = p.name || (p.content && p.content.split(String.fromCharCode(10))[0]) || ''; if(author && author.trim()===username) localMatches.push({ board: k.slice(6), id: p.id, ts: p.ts||p.timestamp, text: p.content }); } catch(e){} }); }); if(localMatches.length){ postsEl.innerHTML = '<strong>Local posts</strong>' + localMatches.map(p=>'<div class="small">/' + escapeHtml(p.board) + '/ • ' + new Date(p.ts).toLocaleString() + ' • <a href="#post-' + escapeHtml(p.board) + '-' + escapeHtml(p.id) + '">view</a></div>').join(''); } else { postsEl.innerHTML = '<div class="small">No local posts found. Click "Fetch remote posts" to search the worker.</div>'; } }
function hideProfileModal(){ const modal = document.getElementById('profileModal'); if(!modal) return; modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); }

async function fetchRemotePosts(username){
  const postsEl = document.getElementById('profilePosts');
  postsEl.innerHTML = '<div class="small">Searching remote posts…</div>';
  const results = [];
  try {
    for(const board in BOARDS){
      const ch = BOARDS[board].channel;
      try {
        const res = await fetch(`${WORKER_BASE.replace(/\/$/,'')}/messages?channel_id=${ch}&limit=200`);
        if(!res.ok) continue;
        const data = await res.json();
        data.forEach(m => {
          try {
            const authorUsername = (m.author && m.author.username) || '';
            const firstLine = (m.content||'').split('\n')[0] || '';
            if(authorUsername === username || firstLine.trim() === username){
              results.push({ board, id: m.id, ts: m.timestamp, text: m.content, url: `https://discord.com/channels/${GUILD_ID}/${ch}/${m.id}` });
            }
          } catch(e){}
        });
      } catch(e){}
    }
  } catch(e){ console.error('fetchRemotePosts error', e); }

  if(results.length === 0){
    postsEl.innerHTML = '<div class="small">No remote posts found for this user (or the worker does not allow /messages requests).</div>';
    return;
  }
  results.sort((a,b) => new Date(b.ts) - new Date(a.ts));
  postsEl.innerHTML = '<strong>Remote posts</strong>' + results.map(p=>`<div class="small">/${escapeHtml(p.board)}/ • ${new Date(p.ts).toLocaleString()} • <a href="${p.url}" target="_blank">view</a></div>`).join('');
}
</script>

<!-- Profile modal -->
<div id="profileModal" class="profile-modal" style="display:none" aria-hidden="true">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <div style="display:flex;align-items:center;gap:10px">
      <div class="avatar" id="profileAvatar">U</div>
      <div>
        <h3 id="profileName">Username</h3>
        <div class="small" id="profileCreated"></div>
      </div>
    </div>
    <div><button id="closeProfile" class="small">Close</button></div>
  </div>
  <div style="margin-top:8px"><button id="fetchRemotePosts" class="small">Fetch remote posts</button></div>
  <div class="profile-posts" id="profilePosts"></div>
</div>

</body>
</html>
