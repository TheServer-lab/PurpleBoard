<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Purple Board — Shared (Worker reader) — Accounts</title>
<link rel="icon" href="data:,">
<style>
:root{
  --bg:#120018; --panel:#241033; --accent:#a86ff9; --muted:#cdb6ff; --text:#efe6ff;
  --card-border: rgba(255,255,255,0.04); --muted-2:#b99bf0; --glass: rgba(255,255,255,0.02);
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,var(--bg),#1b0228);color:var(--text);-webkit-font-smoothing:antialiased}
header{padding:12px;background:linear-gradient(90deg,#1b002b,#2b003f);border-bottom:1px solid var(--card-border);display:flex;align-items:center;gap:12px;justify-content:space-between}
header h1{margin:0;font-size:18px;color:var(--accent)}
.container{max-width:1100px;margin:18px auto;padding:12px;display:grid;grid-template-columns:300px 1fr;gap:14px}
.card{background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.005));padding:12px;border-radius:10px;border:1px solid var(--card-border)}
.board-list button{display:block;width:100%;text-align:left;padding:10px;border-radius:8px;border:0;background:transparent;color:var(--muted);margin-bottom:8px;cursor:pointer}
.board-list button.active{background:rgba(168,111,249,0.08);color:var(--text);box-shadow:0 6px 18px rgba(168,111,249,0.06)}
input[type="text"],textarea,input[type="file"],select,button{width:100%;padding:8px;border-radius:8px;border:1px solid var(--card-border);background:transparent;color:var(--text)}
textarea{resize:vertical}
button.primary{background:var(--accent);border:0;color:#fff;cursor:pointer;padding:8px 10px;border-radius:8px}
.small{font-size:13px;color:var(--muted)}
.thread-list{display:flex;flex-direction:column;gap:12px}
.thread-card{display:flex;gap:12px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);align-items:flex-start;background:rgba(255,255,255,0.01);cursor:pointer;transition:transform .08s,box-shadow .08s}
.thread-card:hover{transform:translateY(-3px);box-shadow:0 10px 30px rgba(0,0,0,0.5)}
.thumb{width:120px;height:auto;border-radius:6px;object-fit:cover}
.meta{font-size:12px;color:var(--muted)}
.greentext{color:#7cffb2}
.quote{background:rgba(255,255,255,0.02);color:var(--muted);padding:4px;border-radius:6px;display:inline-block;cursor:pointer}
.controls{display:flex;gap:8px;align-items:center}
.thread-view{display:flex;flex-direction:column;gap:8px}
.post{padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
.reply{margin-left:18px}
.footer-note{font-size:12px;color:var(--muted);margin-top:6px}
.captcha{display:flex;align-items:center;gap:8px;margin-top:6px}
.bad{color:#ff7b7b}
.debug{font-family:monospace;font-size:12px;color:var(--muted-2);white-space:pre-wrap;margin-top:8px}
.avatar{width:40px;height:40px;border-radius:999px;background:linear-gradient(135deg,#6f3df1,#b76cff);display:inline-flex;align-items:center;justify-content:center;font-weight:700;color:#fff;margin-right:8px}
.post-actions{display:flex;gap:8px;align-items:center;margin-top:8px}
.action-btn{background:transparent;border:1px solid var(--card-border);padding:6px 8px;border-radius:6px;color:var(--muted);cursor:pointer}
.action-btn:hover{color:var(--text);border-color:var(--accent)}
.permalink{font-size:12px;color:var(--muted);margin-left:8px}
.op-badge{background:var(--accent);color:#fff;font-weight:700;padding:2px 6px;border-radius:6px;font-size:12px;margin-left:8px}
.timeago{color:var(--muted);font-size:12px;margin-left:6px}
.empty{color:var(--muted)}
.lightbox{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:9999}
.lightbox img{max-width:95%;max-height:95%;border-radius:8px}
.copy-toast{position:fixed;right:18px;bottom:18px;background:#1b0b2a;padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);color:var(--muted);box-shadow:0 6px 18px rgba(0,0,0,0.6)}
.account-row{display:flex;gap:8px;align-items:center}
.account-box{display:flex;flex-direction:column;gap:6px}
@media (max-width:880px){ .container{grid-template-columns:1fr} .thumb{display:none} }
a{color:var(--accent)}
</style>
</head>
<body>
<header>
  <div style="display:flex;align-items:center;gap:12px"><h1>Purple Board</h1><div class="small">Shared imageboard — posts → Discord webhooks; reads → Cloudflare Worker</div></div>
  <div id="accountArea" class="small"></div>
</header>

<div class="container">
  <aside class="card">
    <div><strong>Boards</strong></div>
    <div class="board-list" id="boardList" style="margin-top:10px"></div>

    <div class="card" style="margin-top:12px">
      <strong>Account</strong>
      <div style="margin-top:8px">
        <div id="authForms"></div>
        <div id="loggedInBox" style="display:none;margin-top:8px">
          <div class="account-row"><div class="avatar" id="accountAvatar">U</div><div class="account-box"><div id="accountName"></div><div class="small" id="accountEmail"></div></div></div>
          <div style="display:flex;gap:8px;margin-top:8px"><button id="logoutBtn" class="small">Logout</button><button id="botLoginBtn" class="small">Login via Bot</button></div>
        </div>
      </div>
      <div class="small" style="margin-top:8px">Register or login to post — names come from profiles. Passwords are hashed in your browser before storage. (Demo only — don't use real passwords.)</div>
    </div>

    <div class="card" style="margin-top:12px">
      <strong>Quick help</strong>
      <div class="small" style="margin-top:8px">Pick a board, post text & image. Click posts to open threads. Use the Share button to share via the website (or copy a Discord permalink).</div>
    </div>
  </aside>

  <main>
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>New Post / Thread</strong></div>
        <div class="small" id="selectedBoardName"></div>
      </div>

      <label class="small" style="margin-top:8px">Comment</label>
      <textarea id="comment" rows="4" placeholder="Say something (use >greentext or >>messageId to quote)"></textarea>

      <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
        <input id="file" type="file" accept="image/*" style="flex:1">
        <label style="display:flex;align-items:center;gap:6px;margin-left:6px"><input id="asThread" type="checkbox"> OP (new thread)</label>
      </div>

      <div class="captcha">
        <label style="display:flex;align-items:center;gap:8px"><input id="fakeCaptcha" type="checkbox"> I'm human (demo)</label>
        <div class="small">Client-side captcha — optional</div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
        <button class="primary" id="postBtn">Post (Ctrl+Enter)</button>
        <div id="status" class="small"></div>
      </div>

      <div class="footer-note">Local cooldown & daily limits enforced for convenience.</div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Threads (shared)</strong>
        <div class="controls">
          <button id="refreshBtn" class="small">Refresh</button>
          <button id="healthBtn" class="small">Worker health</button>
          <div id="debugHint" class="small" style="margin-left:8px"></div>
        </div>
      </div>

      <div id="threads" class="thread-list" style="margin-top:10px"></div>
      <div id="debug" class="debug" style="display:none"></div>
    </div>

    <div class="card" id="threadViewCard" style="display:none">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Thread View</strong>
        <div><button id="backBtn" class="small">Back</button></div>
      </div>
      <div id="threadView" class="thread-view"></div>

      <div style="margin-top:8px" class="post">
        <textarea id="replyText" rows="3" placeholder="Reply"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input id="replyFile" type="file" accept="image/*">
          <button class="primary" id="replyBtn">Reply</button>
          <div id="replyStatus" class="small"></div>
        </div>
      </div>
    </div>

  </main>
</div>

<!-- Lightbox -->
<div id="lightbox" class="lightbox" style="display:none" onclick="hideLightbox()"><img id="lightboxImg" src="" alt=""/></div>

<!-- Copy toast -->
<div id="copyToast" class="copy-toast" style="display:none">Link copied to clipboard</div>

<script>
/* =============== CONFIG (user provided) =============== */
const WORKER_BASE = 'https://pbordworker.dassouraasish.workers.dev';
const BOARDS = {
  "art": { webhook: "https://discord.com/api/webhooks/1456573325148164128/UlQfAb8WE1hWw_uBCs01QPuLjuBg4HAjKAyifGjs0-YDqjIB75Ee1RMvBX0EmoXwE8Xi", channel: "1456573205237203045" },
  "tech": { webhook: "https://discord.com/api/webhooks/1456573404521173041/pxVoHmjnnYTjwEH1EDmf6uMvVbQD3vPogizcyt_5T16AaNUStyw3XyWEniiCvRegprAg", channel: "1456573234009997453" },
  "random": { webhook: "https://discord.com/api/webhooks/1456573475815690395/lb5_p1w6MXf852xPI67v9BPRqSicH_gvpf1C2ki2AmKyb7xL0nUHCrBhsBRrxzSrD26P", channel: "1456573259561701490" }
};
const COOLDOWN_SECONDS = 12;
const DAILY_LIMIT = 200;
const GUILD_ID = '1283171828214534165';
// Optional webhook to store share events or user registrations (user provided)
const SHARE_WEBHOOK = 'https://discord.com/api/webhooks/1456575897443238073/Uva4p8ZmCpq4NSn3ayyuqHaFJWA_gH0SQZ83jNXNi3QSy03L2FVFO88YqW8UsH8PBDbO';
const SYNC_USERS_TO_WEBHOOK = false; // set true if you really want to mirror registration events to webhook (insecure: public)
/* ===================================================== */

const $ = id => document.getElementById(id);
const boardListEl = $('boardList'), selectedBoardNameEl = $('selectedBoardName'), threadsEl = $('threads');
const postBtn = $('postBtn'), refreshBtn = $('refreshBtn'), healthBtn = $('healthBtn'), debugEl = $('debug'), debugHint = $('debugHint');
const copyToast = $('copyToast');
let selectedBoard = null, selectedBoardWebhook = null, viewingThreadId = null;

// small helpers
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }
function timeAgo(ts){ const t = Date.parse(ts); if(isNaN(t)) return ''; const s = Math.floor((Date.now()-t)/1000); if(s<60) return `${s}s`; if(s<3600) return `${Math.floor(s/60)}m`; if(s<86400) return `${Math.floor(s/3600)}h`; return `${Math.floor(s/86400)}d`; }
function initials(name){ if(!name) return 'U'; return name.trim().split(/\s+/).map(p=>p[0].toUpperCase()).slice(0,2).join(''); }

/* ========== Accounts (client-side, demo) ========== */
function randomHex(bytes=8){ const a=new Uint8Array(bytes); crypto.getRandomValues(a); return Array.from(a).map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function hashPassword(salt, password){ const enc = new TextEncoder(); const data = enc.encode(salt + '|' + password); const buf = await crypto.subtle.digest('SHA-256', data); return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function loadUsers(){ return JSON.parse(localStorage.getItem('pb_users')||'[]'); }
function saveUsers(u){ localStorage.setItem('pb_users', JSON.stringify(u)); }
function getCurrentUser(){ return JSON.parse(localStorage.getItem('pb_current')||'null'); }
function setCurrentUser(user){ localStorage.setItem('pb_current', JSON.stringify(user)); updateAccountUI(); }
function logout(){ localStorage.removeItem('pb_current'); updateAccountUI(); }

function renderAuthForms(){ const out = document.createElement('div');
  out.innerHTML = `
    <div id="authWrap">
      <input id="regUser" placeholder="username" style="margin-top:6px">
      <input id="regPass" placeholder="password" type="password" style="margin-top:6px">
      <div style="display:flex;gap:8px;margin-top:6px"><button id="regBtn" class="small">Register</button><button id="toLogin" class="small">Go to Login</button></div>
      <div style="height:8px"></div>
      <input id="loginUser" placeholder="username" style="margin-top:6px;display:none">
      <input id="loginPass" placeholder="password" type="password" style="margin-top:6px;display:none">
      <div style="display:flex;gap:8px;margin-top:6px"><button id="loginBtn" class="small" style="display:none">Login</button><button id="toReg" class="small" style="display:none">Go to Register</button></div>
    </div>
  `;
  $('authForms').innerHTML=''; $('authForms').appendChild(out);
  // wire
  $('regBtn').addEventListener('click', onRegister);
  $('toLogin').addEventListener('click', ()=>{ $('regUser').style.display='none'; $('regPass').style.display='none'; $('regBtn').style.display='none'; $('toLogin').style.display='none'; $('loginUser').style.display=''; $('loginPass').style.display=''; $('loginBtn').style.display=''; $('toReg').style.display=''; });
  $('toReg').addEventListener('click', ()=>{ location.reload(); });
  $('loginBtn').addEventListener('click', onLogin);
}

async function onRegister(){ const u = $('regUser').value.trim(); const p = $('regPass').value; if(!u || !p){ alert('Provide username & password'); return; }
  const users = loadUsers(); if(users.find(x=>x.username===u)){ alert('Username already exists'); return; }
  const salt = randomHex(12); const h = await hashPassword(salt,p);
  users.push({ username: u, salt, hash: h, created: new Date().toISOString() }); saveUsers(users);
  setCurrentUser({ username: u });
  if(SYNC_USERS_TO_WEBHOOK && SHARE_WEBHOOK){ try{ const fd = new FormData(); fd.append('content', `REGISTER: ${u} — ${new Date().toISOString()}`); await fetch(webhookWithWait(SHARE_WEBHOOK), { method:'POST', body: fd }); }catch(e){ console.warn('user sync failed',e); } }
  alert('Registered and logged in as ' + u);
}

async function onLogin(){ const u = $('loginUser').value.trim() || $('regUser').value.trim(); const p = $('loginPass').value || $('regPass').value; if(!u || !p){ alert('Provide username & password'); return; }
  const users = loadUsers(); const found = users.find(x=>x.username===u); if(!found){ alert('No such user'); return; }
  const h = await hashPassword(found.salt, p);
  if(h === found.hash){ setCurrentUser({ username: u }); alert('Logged in as ' + u); }
  else alert('Invalid password');
}

function updateAccountUI(){ const cur = getCurrentUser(); const area = $('accountArea'); if(cur && cur.username){ $('loggedInBox').style.display='block'; $('authForms').style.display='none'; $('accountName').textContent = cur.username; $('accountAvatar').textContent = initials(cur.username); $('accountEmail').textContent = ''; } else { $('loggedInBox').style.display='none'; $('authForms').style.display='block'; renderAuthForms(); } }

/* try to call a bot login endpoint on the worker (optional). This requires a server-side implementation. */
async function botLogin(){ const cur = getCurrentUser(); if(!cur || !cur.username){ alert('Login first'); return; }
  if(!WORKER_BASE){ alert('No worker base set'); return; }
  try{ const res = await fetch(WORKER_BASE.replace(/\/$/,'') + '/bot-login', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ username: cur.username }) }); const txt = await res.text(); alert('Bot login response: ' + res.status + '\n' + txt); }catch(e){ alert('Bot login failed — worker may not implement /bot-login'); console.error(e); }
}

/* ========== end accounts ========== */

/* init UI */
function init(){
  boardListEl.innerHTML = '';
  for(const k in BOARDS){
    const b = document.createElement('button'); b.textContent = '/'+k+'/'; b.dataset.board = k; b.onclick = ()=> selectBoard(k,b); boardListEl.appendChild(b);
  }
  const first = Object.keys(BOARDS)[0]; if(first) selectBoard(first, boardListEl.querySelector('button'));
  postBtn.addEventListener('click', onPost);
  refreshBtn.addEventListener('click', ()=> loadThreads(true));
  healthBtn.addEventListener('click', checkHealth);
  $('backBtn').addEventListener('click', ()=> $('threadViewCard').style.display='none');
  $('replyBtn').addEventListener('click', onReply);
  $('logoutBtn').addEventListener('click', ()=>{ logout(); });
  $('botLoginBtn').addEventListener('click', ()=> botLogin());
  debugHint.textContent = 'Worker: ' + (WORKER_BASE?WORKER_BASE.replace(/^https?:\/\//,''):'(not set)');
  document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); if(document.activeElement && (document.activeElement.tagName==='TEXTAREA' || document.activeElement.tagName==='INPUT')) postBtn.click(); }});
  updateAccountUI();
  loadThreads(false);
}
init();

// select board
function selectBoard(name, btn){
  boardListEl.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
  if(btn) btn.classList.add('active');
  selectedBoard = name; selectedBoardWebhook = BOARDS[name].webhook;
  selectedBoardNameEl.textContent = '/'+name+'/';
  $('threadViewCard').style.display = 'none';
}

/* webhook helper */
function webhookWithWait(url){ return url.includes('?') ? url + '&wait=true' : url + '?wait=true' }

/* Post */
async function onPost(){
  $('status').textContent = '';
  if(!selectedBoard){ $('status').textContent='Select a board'; return; }
  const cur = getCurrentUser();
  const author = cur && cur.username ? cur.username : 'Anonymous';
  const comment = $('comment').value.trim(); const file = $('file').files[0]; const isThread = $('asThread').checked;
  if(!comment && !file){ $('status').textContent='Write something or attach an image'; return; }
  if(!$('fakeCaptcha').checked){ $('status').textContent='Complete captcha (demo)'; return; }

  // cooldown & daily
  const lastKey = `last_${selectedBoard}`; const last = Number(localStorage.getItem(lastKey)||0); const nowTs = Date.now();
  if(nowTs - last < COOLDOWN_SECONDS*1000){ $('status').textContent = `Cooldown: wait ${Math.ceil((COOLDOWN_SECONDS*1000 - (nowTs-last))/1000)}s`; return; }
  const dailyKey = `daily_${selectedBoard}`; const daily = JSON.parse(localStorage.getItem(dailyKey)||'[]').filter(t=>nowTs-t<24*3600*1000);
  if(daily.length >= DAILY_LIMIT){ $('status').textContent='Daily limit reached'; return; }

  $('status').textContent = 'Posting...';
  const fd = new FormData(); const content = (author?author+'\n':'') + comment + (isThread? '\n[THREAD]':'');
  fd.append('content', content); if(file) fd.append('file', file);

  try {
    const r = await fetch(webhookWithWait(selectedBoardWebhook), { method: 'POST', body: fd });
    if(!r.ok) throw new Error('post failed: '+r.status);
    const json = await r.json().catch(()=>({ id:String(Date.now()), content }));
    const localKey = `posts_${selectedBoard}`; const posts = JSON.parse(localStorage.getItem(localKey)||'[]');
    const post = { id: json.id||String(Date.now()), content: json.content||content, ts: json.timestamp||new Date().toISOString(), attachments: json.attachments||[], parent: null, isOP: isThread, name: author };
    posts.unshift(post); localStorage.setItem(localKey, JSON.stringify(posts));
    localStorage.setItem(lastKey, String(nowTs)); daily.unshift(nowTs); localStorage.setItem(dailyKey, JSON.stringify(daily));
    $('status').textContent='Posted ✓'; $('comment').value=''; $('file').value=''; $('asThread').checked=false;
    setTimeout(()=> loadThreads(true), 1200);
  } catch(e){ console.error(e); $('status').textContent='Post failed (console)'; }
}

/* Reply */
async function onReply(){
  const threadId = viewingThreadId; if(!threadId){ $('replyStatus').textContent='No thread selected'; return; }
  const cur = getCurrentUser();
  const author = cur && cur.username ? cur.username : 'Anonymous';
  const text = $('replyText').value.trim(); const file = $('replyFile').files[0];
  if(!text && !file){ $('replyStatus').textContent='Write something or attach image'; return; }
  const content = (author?author+'\n':'') + `>>${threadId}\n` + text;
  const fd = new FormData(); fd.append('content', content); if(file) fd.append('file', file);
  $('replyStatus').textContent = 'Posting reply...';
  try{
    const r = await fetch(webhookWithWait(selectedBoardWebhook), { method:'POST', body: fd });
    if(!r.ok) throw new Error('reply failed: '+r.status);
    const json = await r.json().catch(()=>({ id:String(Date.now()), content }));
    const localKey = `posts_${selectedBoard}`; const posts = JSON.parse(localStorage.getItem(localKey)||'[]');
    const post = { id: json.id||String(Date.now()), content: json.content||content, ts: json.timestamp||new Date().toISOString(), attachments: json.attachments||[], parent: threadId, isOP:false, name:author };
    posts.unshift(post); localStorage.setItem(localKey, JSON.stringify(posts));
    $('replyStatus').textContent='Replied ✓'; $('replyText').value=''; $('replyFile').value='';
    renderThreadView(threadId); setTimeout(()=> loadThreads(true),1200);
  }catch(e){ console.error(e); $('replyStatus').textContent='Error posting reply'; }
}

/* Load via Worker */
async function loadThreads(force=false){
  threadsEl.innerHTML = 'Loading…'; debugEl.style.display='none'; debugEl.textContent='';
  if(!WORKER_BASE || WORKER_BASE.includes('PASTE')) { threadsEl.innerHTML='Set WORKER_BASE in HTML'; return; }
  if(!selectedBoard){ threadsEl.innerHTML='Select a board'; return; }
  const channel = BOARDS[selectedBoard] && BOARDS[selectedBoard].channel; if(!channel){ threadsEl.innerHTML='Board missing channel id'; return; }

  try{
    const url = `${WORKER_BASE.replace(/\/$/,'')}/messages?channel_id=${channel}&limit=80`;
    const res = await fetch(url);
    if(!res.ok){
      const txt = await res.text().catch(()=>'');
      let friendly = `Server returned ${res.status}`;
      try{
        const parsed = JSON.parse(txt);
        if(parsed && parsed.error === 'discord_error' && parsed.text){
          try{
            const inner = JSON.parse(parsed.text);
            if(inner && inner.message && inner.code){
              friendly = `Discord API: ${inner.message} (code ${inner.code})`;
              if(inner.code===10003 || /Unknown Channel/i.test(inner.message)) friendly += ' — Unknown Channel. Check channel ID & bot permissions.';
            } else friendly = `Discord API error: ${JSON.stringify(inner)}`;
          }catch(e){ friendly = `Discord error: ${parsed.text}`; }
        } else if(parsed && parsed.message) friendly = `Discord: ${parsed.message}`;
        else friendly = `Server: ${txt}`;
      }catch(e){ friendly = `Server returned ${res.status} — response: ${txt}`; }
      threadsEl.innerHTML = `Failed to load messages (server returned ${res.status})`;
      debugEl.style.display='block'; debugEl.textContent = `URL: ${url}\nStatus: ${res.status}\nFriendly: ${friendly}\nRaw:\n${txt}`;
      return;
    }
    const data = await res.json();
    const localKey = `posts_${selectedBoard}`; const localPosts = JSON.parse(localStorage.getItem(localKey)||'[]');
    const byId = new Map(); data.forEach(m=>byId.set(m.id,m));
    localPosts.forEach(lp=>{ if(!byId.has(lp.id)) byId.set(lp.id,{ id:lp.id, content:lp.content, timestamp:lp.ts||lp.timestamp, author_name:lp.name||'You', attachments:lp.attachments||[], parent:lp.parent||null, isOP:lp.isOP||false }); });
    const merged = Array.from(byId.values()).sort((a,b)=> new Date(b.timestamp) - new Date(a.timestamp));
    const threads = groupToThreads(merged);
    renderThreads(threads);
  }catch(e){ console.error(e); threadsEl.innerHTML='Failed to load messages (console)'; debugEl.style.display='block'; debugEl.textContent=String(e); }
}

/* Group into threads */
function groupToThreads(msgs){
  const map = new Map(); msgs.forEach(m=>map.set(m.id,m));
  const threads = new Map(); msgs.forEach(m=>threads.set(m.id,{ op:m, replies:[] }));
  msgs.forEach(m=>{
    if(!m.content) return;
    const match = m.content.match(/>>(\d{1,20})/);
    if(match){
      const ref = match[1];
      if(map.has(ref)){
        const t = threads.get(ref) || { op: map.get(ref), replies:[] };
        t.replies.push(m); threads.set(ref,t);
        if(threads.has(m.id)) threads.delete(m.id);
      }
    }
  });
  return Array.from(threads.values()).sort((a,b)=> new Date(b.op.timestamp) - new Date(a.op.timestamp));
}

/* Render threads (posts clickable to open thread) */
function renderThreads(threads){
  threadsEl.innerHTML = '';
  if(!threads.length){ threadsEl.innerHTML = '<div class="empty">No threads found.</div>'; return; }
  threads.forEach(t=>{
    const op = t.op;
    const card = document.createElement('div'); card.className='thread-card';
    card.addEventListener('click', (e)=>{ if(e.target.closest('.action-btn')) return; openThread(op.id); });

    const left = document.createElement('div'); left.style.width='120px';
    if(op.attachments && op.attachments[0] && op.attachments[0].url){
      const img=document.createElement('img'); img.src=op.attachments[0].url; img.className='thumb'; img.loading='lazy';
      img.onclick=(ev)=>{ ev.stopPropagation(); showLightbox(op.attachments[0].url); };
      left.appendChild(img);
    }
    const right = document.createElement('div'); right.style.flex='1';
    const header = document.createElement('div');
    const avatar = document.createElement('span'); avatar.className='avatar'; avatar.textContent = initials(op.author_name || (op.name||'U'));
    header.appendChild(avatar);
    const title = document.createElement('div'); title.innerHTML = `<strong>${escapeHtml(op.author_name||op.name||'unknown')}</strong> <span class="timeago">${timeAgo(op.timestamp)}</span>`;
    if(op.isOP || (op.content && /\[THREAD\]/i.test(op.content))) { const b = document.createElement('span'); b.className='op-badge'; b.textContent='OP'; title.appendChild(b); }
    header.appendChild(title);
    const body = document.createElement('div'); body.style.marginTop='8px'; body.innerHTML = formatText(op.content||'');
    const actions = document.createElement('div'); actions.className='post-actions';
    const shareBtn = document.createElement('button'); shareBtn.className='action-btn'; shareBtn.textContent='Share'; shareBtn.onclick = (e)=>{ e.stopPropagation(); sharePost(op.id); };
    const shareSiteBtn = document.createElement('button'); shareSiteBtn.className='action-btn'; shareSiteBtn.textContent='Share (site)'; shareSiteBtn.onclick = (e)=>{ e.stopPropagation(); shareViaSite(op.id, op); };
    const quoteBtn = document.createElement('button'); quoteBtn.className='action-btn'; quoteBtn.textContent='Quote'; quoteBtn.onclick = (e)=>{ e.stopPropagation(); insertQuote(op.id); };
    const profileBtn = document.createElement('button'); profileBtn.className='action-btn'; profileBtn.textContent='Profile'; profileBtn.onclick = (e)=>{ e.stopPropagation(); openProfile(op.author_name||op.name||'unknown'); };
    const repliesCount = document.createElement('span'); repliesCount.className='permalink'; repliesCount.textContent = `${t.replies.length} replies`;
    actions.appendChild(shareBtn); actions.appendChild(shareSiteBtn); actions.appendChild(quoteBtn); actions.appendChild(profileBtn); actions.appendChild(repliesCount);

    right.appendChild(header); right.appendChild(body); right.appendChild(actions);
    card.appendChild(left); card.appendChild(right);
    threadsEl.appendChild(card);

    // enable clicking >>id spans inside this card
    body.querySelectorAll('.quote').forEach(q=>{
      q.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        const id = q.dataset.id;
        if(findThreadById(id)) openThread(id);
        else { insertQuote(id); flash(`Quoted >>${id} into compose box`); }
      });
    });
  });
}

/* Thread view & rendering */
function openThread(opId){ viewingThreadId = opId; $('threadViewCard').style.display='block'; renderThreadView(opId); window.scrollTo({top:0,behavior:'smooth'}); }
function renderThreadView(opId){
  const wrap = $('threadView'); wrap.innerHTML='Loading…';
  const channel = BOARDS[selectedBoard].channel;
  fetch(`${WORKER_BASE.replace(/\/$/,'')}/messages?channel_id=${channel}&limit=200`).then(r=>r.json()).then(data=>{
    const byId = new Map(); data.forEach(m=>byId.set(m.id,m));
    const local = JSON.parse(localStorage.getItem(`posts_${selectedBoard}`) || '[]');
    local.forEach(p=>{ if(!byId.has(p.id)) byId.set(p.id,{ id:p.id, content:p.content, timestamp:p.ts, author_name:p.name||'You', attachments:p.attachments||[], parent:p.parent||null }); });
    const op = byId.get(opId);
    if(!op){ wrap.innerHTML = '<div class="small">Thread not found — try Refresh or open in Discord</div>'; return; }
    wrap.innerHTML = '';
    const opDiv = document.createElement('div'); opDiv.className='post';
    opDiv.innerHTML = `<div style="font-weight:700">${escapeHtml(op.author_name||op.name||'unknown')}</div><div class="meta">${new Date(op.timestamp).toLocaleString()} <span class="timeago">(${timeAgo(op.timestamp)})</span></div><div style="margin-top:8px">${formatText(op.content)}</div>`;
    if(op.attachments && op.attachments[0] && op.attachments[0].url){ const im=document.createElement('img'); im.src=op.attachments[0].url; im.style.maxWidth='640px'; im.style.marginTop='8px'; im.onclick=()=>showLightbox(im.src); opDiv.appendChild(im); }
    wrap.appendChild(opDiv);
    // append profile button to OP meta
    const opMeta = opDiv.querySelector('.meta'); if(opMeta){ const btn=document.createElement('button'); btn.className='action-btn'; btn.textContent='Profile'; btn.style.marginLeft='8px'; btn.onclick=()=>openProfile(op.author_name||op.name||'unknown'); opMeta.appendChild(btn); }
    const replies = [];
    byId.forEach(m=>{ if(m.content && m.content.includes('>>'+opId)) replies.push(m); });
    local.filter(p=>p.parent===opId).forEach(lp=>replies.push(lp));
    replies.sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));
    replies.forEach(r=>{ const d = document.createElement('div'); d.className='post reply'; d.innerHTML = `<div class="meta">${escapeHtml(r.author_name||r.name||'unknown')} • ${new Date(r.timestamp).toLocaleString()} <span class="timeago">(${timeAgo(r.timestamp)})</span></div><div style="margin-top:6px">${formatText(r.content)}</div>`; if(r.attachments && r.attachments[0] && r.attachments[0].url){ const im=document.createElement('img'); im.src=r.attachments[0].url; im.style.maxWidth='420px'; im.style.marginTop='8px'; im.onclick=()=>showLightbox(im.src); d.appendChild(im); }
      // append profile button to reply meta
      const metaEl = d.querySelector('.meta'); if(metaEl){ const pbtn = document.createElement('button'); pbtn.className='action-btn'; pbtn.textContent='Profile'; pbtn.style.marginLeft='8px'; pbtn.onclick = ()=> openProfile(r.author_name||r.name||'unknown'); metaEl.appendChild(pbtn); }
      wrap.appendChild(d); });
  }).catch(e=>{ console.error(e); wrap.innerHTML='<div class="small">Failed to load thread</div>'; });
}

/* formatting & helpers */
function formatText(text){
  if(!text) return '';
  let t = escapeHtml(text);
  t = t.replace(/^&gt;(.+)$/gm, (m,p1) => `<div class="greentext">&gt;${escapeHtml(p1)}</div>`);
  t = t.replace(/&gt;&gt;(\d{1,20})/g, (m,id) => `<span class="quote" data-id="${id}">&gt;&gt;${id}</span>`);
  t = t.replace(/(https?:\/\/[^\s]+)/g, m => `<a href="${m}" target="_blank">${m}</a>`);
  return t.replace(/\n/g,'<br>');
}
function findThreadById(id){ return threadsEl.querySelector(`.quote[data-id="${id}"]`); }
function discordPermalink(messageId){ const channel = BOARDS[selectedBoard].channel; return `https://discord.com/channels/${GUILD_ID}/${channel}/${messageId}`; }

function openProfile(username){ if(!username) return; const url = WORKER_BASE.replace(/\/$/,'') + '/profile?username=' + encodeURIComponent(username); window.open(url, '_blank'); }

async function sharePost(messageId){ // legacy: copy discord permalink & navigator.share
  const url = discordPermalink(messageId);
  try{ await navigator.clipboard.writeText(url); showCopyToast('Link copied'); if(navigator.share){ try{ await navigator.share({ title: 'Purple Board post', url }); }catch(e){} } }catch(e){ console.error('share failed', e); showCopyToast('Copy failed'); }
}

async function shareViaSite(messageId, post){
  // create a site-friendly permalink (fragment) so the site can open it later
  const siteUrl = window.location.origin + window.location.pathname + `#post-${selectedBoard}-${messageId}`;
  try{ await navigator.clipboard.writeText(siteUrl); showCopyToast('Site link copied'); }catch(e){ console.warn('copy failed', e); }
  // optionally notify SHARE_WEBHOOK so the site (or Discord) can announce the share (this will publicly post to that webhook)
  if(SHARE_WEBHOOK){
    try{
      const author = (post && (post.author_name||post.name)) || 'unknown';
      const fd = new FormData(); fd.append('content', `${author} shared ${siteUrl}`);
      await fetch(webhookWithWait(SHARE_WEBHOOK), { method:'POST', body: fd });
    }catch(e){ console.warn('share webhook failed',e); }
  }
  // if navigator.share is available, open system share too
  if(navigator.share){ try{ await navigator.share({ title: 'Purple Board — post', url: siteUrl }); }catch(e){} }
}

function insertQuote(id){ const ta = $('comment'); ta.focus(); const v = ta.value; const toIns = (v && !v.endsWith('\n')? '\n':'') + `>>${id}\n`; ta.value = v + toIns; flash(`Inserted >>${id}`); }
function flash(msg){ const s = $('status'); s.textContent = msg; setTimeout(()=>{ if(s.textContent===msg) s.textContent = ''; }, 2200); }
function showLightbox(src){ $('lightboxImg').src = src; $('lightbox').style.display = 'flex'; }
function hideLightbox(){ $('lightbox').style.display = 'none'; $('lightboxImg').src = ''; }
let toastTimer = null;
function showCopyToast(text){ copyToast.textContent = text || 'Copied'; copyToast.style.display = 'block'; clearTimeout(toastTimer); toastTimer = setTimeout(()=> copyToast.style.display = 'none', 2200); }
function checkHealth(){ if(!WORKER_BASE){ alert('Set WORKER_BASE'); return; } fetch(WORKER_BASE.replace(/\/$/,'') + '/health').then(async r=>{ const txt = await r.text(); alert('Health: '+r.status + '\n' + txt); }).catch(e=>{ alert('Health check failed — see console'); console.error(e); }); }

/* initial auto-refresh */
setInterval(()=> loadThreads(true), 20000);
/* expose for console */
window.loadThreads = loadThreads;
window.openThread = openThread;

</script>
</body>
</html>
